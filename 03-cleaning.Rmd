# Data transformation

```{r, include=FALSE}
source("srcs/helpers.R")
```

## Data file

```{r,eval=FALSE}
name.basics = fread(file = 'data/input/name.basics.tsv')
principals = fread(file = 'data/input/title.principals.tsv')
#episode = fread(file = 'data/input/title.episode.tsv')
#crew = fread(file = 'data/input/title.crew.tsv') # director and writer!
ratings = fread('data/input/title.ratings.tsv')
basics <- fread('data/input/title.basics.tsv')

name.basics %>% head(100) -> name.basics_head
principals %>% head(100) -> principals_head
ratings %>% head(100) -> ratings_head
basics %>% head(100) -> basics_head

save(name.basics_head, principals_head, ratings_head, basics_head,
     file = "data/processing/data_samples.RData")
```

```{r}
load(file = "data/processing/data_samples.RData")
```

### basic data

```{r}
basics_head %>% 
  get_DT(default_show = 5)
```

### Rating data

```{r}
ratings_head %>%
  get_DT(default_show = 5)
```

### Crew data
```{r}
principals_head %>%
  get_DT(default_show = 5)
```



### Budget data

```{r}
budget <- readxl::read_xlsx( 'data/input/budget.xlsx') 
budget %>%
  head(100) %>%
  get_DT(default_show = 5)
```





## Merge Data

### Limit the scope

At this report, we dive in the "movies", and especially those with box office (go the thereter). But the original dataset contains all these 10 types:

```{r,eval=FALSE}
ratings %>% 
  inner_join(basics) %>%
  as_tibble() -> imdb
save(imdb, file = "data/processing/imdb.RData")
```


```{r}
load(file = "data/processing/imdb.RData")
imdb %>%
  #filter(titleType=="tvMovie") %>% 
  group_by(titleType) %>%
  mutate(n = n(),
         top1V = max(numVotes)) %>%
  group_by(titleType) %>%
  arrange(-numVotes) %>%
  slice(1:3) %>%
  summarise(`Number of work` = max(n),
            `Highest Vote` = max(top1V),
            `Top 3 popular voted` = paste0(primaryTitle, collapse = "<br/>")) %>%
  mutate(titleType = ifelse(grepl("Movie", titleType, ignore.case = T), 
                            paste0('<span style="background-color: #277cee44">',
                                   titleType,
                                   '</span>'),
                            titleType)) %>% 
  arrange(-`Number of work`) %>%
get_DT(button = F, default_show = 20)

```



- We only focus on `movie` and `tvMovie` (as some of them have box office, like [High School Musical 3: Senior Year](https://www.the-numbers.com/movies/franchise/High-School-Musical#tab=summary)). And we will use them to map other data.

### Join all table

For basic and rating data, we can use the title id `tconst` to merge directly.

```{r}
imdb %>% 
  filter(titleType %in% c("movie", "tvMovie")) -> imdb_mv
```


From multiple data source, we need to map them by movie name and it's alias.
However, the `budget` data acquired from [numbers](https://www.the-numbers.com/movie/budgets/all/1) is extremely difficult to process.

```{r,eval=FALSE}
akas = fread(file = 'data/input/title.akas.tsv')
budget <- readxl::read_xlsx( 'data/input/budget.xlsx') 
budget %<>%
  mutate(ReleaseDate2 = as.Date(lubridate::parse_date_time(ReleaseDate, "%b %d, %Y")))  %>% 
  mutate(ReleaseDate3 = str_extract(ReleaseDate, "[0-9]+"))  %>% 
  mutate(RealeaseYear = case_when(
    !is.na(ReleaseDate2) ~ year(ReleaseDate2),
    !is.na(ReleaseDate3) ~ as.integer(ReleaseDate3),
    T ~ NA_integer_
  )) %>%
  select(-c(ReleaseDate2, ReleaseDate3)) %>%
  mutate(movie_pure_name = tolower(gsub('[[:space:]]+|[[:punct:]]+', '', Movie)))



akas %>%
   transmute(tconst = titleId, 
             title,
             movie_pure_name = tolower(gsub('[[:space:]]+|[[:punct:]]+', '', title))) %>% 
   inner_join(imdb_mv %>% 
                transmute(tconst,
                          RealeaseYear = as.integer(startYear),
                          numVotes)) %>%
  unique -> akas_mapper


budget_matched = list()
# Safest way: name + year
## use movie primary name + year to map to tconst

budget %>% 
  filter(!is.na(RealeaseYear)) %>%
  inner_join(imdb_mv %>% transmute(tconst, numVotes, Movie = primaryTitle, RealeaseYear = as.integer(startYear))) %>%
  # Resolve conflict
  group_by(Movie, RealeaseYear) %>%
  filter(numVotes == max(numVotes)) %>%
  ungroup -> budget_matched[[1]]

## use movie original name + year to map to tconst
budget %>% 
  anti_join(bind_rows(budget_matched)) %>%
  inner_join(imdb_mv %>% transmute(tconst, numVotes, Movie = originalTitle, RealeaseYear = as.integer(startYear))) %>%
  # Resolve conflict
  group_by(Movie, RealeaseYear) %>%
  filter(numVotes == max(numVotes)) %>%
  ungroup -> budget_matched[[2]]

## use movie akas(drop punct) + year to map to tconst
budget %>%
  anti_join(bind_rows(budget_matched)) %>%
  inner_join(akas_mapper %>% select(tconst, movie_pure_name, RealeaseYear, numVotes)) %>%
  unique %>%
  # Resolve conflict
  group_by(Movie, RealeaseYear) %>%
  filter(numVotes == max(numVotes)) -> budget_matched[[3]]

# Not the best: only use name, and use num Votes to determine which one it refers to.
budget %>%
  anti_join(bind_rows(budget_matched)) %>%
  inner_join(akas_mapper %>% select(tconst, movie_pure_name, numVotes)) %>%
  unique %>% 
  group_by(Movie, RealeaseYear) %>%
  filter(numVotes == max(numVotes)) -> budget_matched[[4]]
  
# Worst: fuzzy matching name + year -  like Star Wars Ep. VII: The Force Awakens with Star Wars: Episode VII
stringdist_join <- function(word){
  tibble(word = word) %>%
  bind_cols(akas_mapper) %>%
    mutate(stringdist = stringdist(word, title, method="osa")) %>%
    filter(stringdist < 0.5 * nchar(word)) %>%
    arrange(-stringdist) -> result
  
  if(nrow(result)==0){
    return(NA)
  }else{
    return(result %>% slice(1) %>% pull(tconst))
  }
}
library(stringdist)
budget %>%
  anti_join(bind_rows(budget_matched)) %>% # takes about 5mins to run!
  rowwise() %>%
  mutate(fuzzy_join_id = stringdist_join(Movie)) -> budget_5


budget_5 %>%
  rename(tconst = fuzzy_join_id) -> budget_matched[[5]]

bind_rows(budget_matched) %>%
  
  distinct(Movie, ReleaseDate, RealeaseYear, tconst, ProductionBudget, DomesticGross, WorldwideGross) %>%
  group_by(tconst) %>%
  filter(RealeaseYear == max(RealeaseYear),
         WorldwideGross == max(WorldwideGross)) %>%
  ungroup -> budget_tconst_mapper
save(budget_tconst_mapper, file="data/processing/budget_tconst_mapper.RData")

```

After a tedious clean, we get this data to map them to imdb database:

```{r}
list(load(file="data/processing/budget_tconst_mapper.RData"))
budget_tconst_mapper %>% 
  get_DT()
```

```{r}
imdb_mv %>%
  left_join(budget_tconst_mapper %>%
              select(-c(Movie, ReleaseDate)) %>%
              mutate_at(c("ProductionBudget", "DomesticGross", "WorldwideGross"), 
                        ~ str_remove_all(., "\\$|,") %>% as.numeric()) %>%
              mutate(Profit = WorldwideGross - ProductionBudget,
                     ROI = WorldwideGross / ProductionBudget) ) %>% as.data.frame() %>% arrange(-numVotes) -> imdb_mv_cleaned
```





Add crew and priciples

```{r,eval=FALSE}
library(magick)
library(cowplot)

principals %>% 
  right_join(imdb_mv_cleaned) %>%
  left_join(name.basics) %>%
  group_by(nconst, primaryName, category) %>%
  summarise(movies_in = n() ,
            total_voted = sum(numVotes, na.rm=T),
            weighted_avg_rating = sum(averageRating * numVotes, na.rm = T) / total_voted) %>%
  ungroup -> imdb_person

imdb_person %>%
  filter(movies_in >= 3,
         category %in% c("director", "actor", "actress")) %>%
  mutate(category = ifelse(category == "director", category, "actor & actress")) %>%
  arrange(-total_voted) %>%
  group_by(category) %>%
  slice(1:30) %>% ungroup %>%
  split(~category) -> imdb_people

save(imdb_people, file="data/processing/imdb_people")


```




## Data Preprocess

- Missing value recognition

Then, we need to understand how the NA is encoded in the dataset. So we calculate 15 most common value among each columns:

```{r}
imdb_mv_cleaned %>%
  mutate_all(~as.character(.)) %>%
  pivot_longer(1:ncol(.)) %>%
  group_by(name, value) %>%
  summarise(nunique = n()) %>%
  group_by(name) %>%
  arrange(-nunique) %>%
  slice(1:15) %>%
  get_DT(default_show = 7)
```

  - Apparently, `\N`, for example, is likely to be one kind of tag for missing value among:

  ```r
  SIGN_of_MISSING <- c('\\N', "", "[]", "	#N/A", "#N/A")
  ```

- Delete movie start at 2022 or later.

```{r}
SIGN_of_MISSING <- c('\\N', "", "[]", "	#N/A", "#N/A")
imdb_mv_cleaned %>%
  mutate_all( ~ifelse(. %in% SIGN_of_MISSING, NA, .) ) %>%
  mutate(isAdult = ifelse(isAdult %in% c('0', '1'), isAdult, NA),
         startYear = as.numeric(startYear)) %>%
  filter(startYear <= 2021) %>%
  select(-RealeaseYear) -> imdb_mv_cleaned_2

```




- Noted that the `genres` column is not cleaned data type. Therefore, we

  - create a `mainGenres` column to represent the main genres of the movie.
  
  - create a one-to-many mapping table for each movie in order to analysis, e.g, aveage votes for each genres.


```{r,eval=FALSE}
imdb_mv_cleaned_2 %>% 
  select(tconst, genres, numVotes) %>%
  separate_rows(genres, sep = ",") -> movie_genre_map

imdb_mv_cleaned_2 %>%
  separate(genres, 
           into = c("mainGenres", "secondGneres", "thirdGenres"),
           sep = ",") -> imdb_pure

imdb_pure %>%
  group_by(mainGenres) %>%
  summarise(n = n()) %>%
  arrange(-n) %>%
  mutate(Genres_type = ifelse(min_rank(-n) <=10, mainGenres, "Others") %>%
           factor %>% fct_relevel("Others", after=Inf)) -> geners_type_map

movie_genre_map %>%
  left_join(imdb_pure %>% select(tconst, averageRating, numVotes)) %>%
  group_by(genres) %>%
  summarise(n = sum(numVotes, na.rm=T)) %>%
  arrange(-n) %>%
  mutate(Genres_type = ifelse(min_rank(-n) <=10, genres, "Others") %>%
           factor %>% fct_relevel("Others", after=Inf)) -> geners_type_map_2

save(movie_genre_map, file = "data/processing/movie_genre_map.RData" )
save(imdb_pure, file = "data/processing/imdb(cleaned).RData")
save(geners_type_map, geners_type_map_2, file = "data/processing/genres_mappers.RData")
```


```{r,eval=FALSE}
load(file = "data/processing/imdb(cleaned).RData")
load(file = "data/processing/genres_mappers.RData")
budget_tconst_mapper %>%
  mutate_at(c("ProductionBudget", "DomesticGross", "WorldwideGross"), 
            ~ str_remove_all(., "\\$|,") %>% as.numeric()) %>%
  left_join(imdb_pure) %>%
  left_join(geners_type_map_2, by = c("mainGenres" = "genres")) %>% 
  select(RealeaseYear, Movie, WorldwideGross, genres = Genres_type) -> temp

cum_best_10 = list()
for(year in 1933:2021){
  temp %>%
    filter(RealeaseYear <= year) %>%
    arrange(-WorldwideGross) %>%
    slice(1:10)  %>%
    mutate(RealeaseYear = year) -> cum_best_10[[as.character(year)]]
}

bind_rows(cum_best_10) -> datarows
write.csv(datarows, "data/processing/d3input.csv",row.names=F)
write(c("var movie_data = ["), "data/processing/d3input.txt", append=F)
for(i in 1:(nrow(datarows)-1)){
  datarow = datarows %>% slice(i)
  write(
    paste0('    {year:', pull(datarow, 1),
        ',name:"', pull(datarow, 2),'"',
        ',genre:"', pull(datarow, 4),'"',
        ',box_offics:', pull(datarow, 3),
        '},'),
    "data/processing/d3input.txt",
    append=T
  )
}
datarow = datarows %>% slice(nrow(datarows))
write(
  paste0('    {year:', pull(datarow, 1),
      ',name:"', pull(datarow, 2),'"',
      ',genre:"', pull(datarow, 4),'"',
      ',box_offics:', pull(datarow, 3),
      '}'),
  "data/processing/d3input.txt",
  append=T
)
write("];", "data/processing/d3input.txt", append=T)
```
